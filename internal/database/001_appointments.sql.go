// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 001_appointments.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (id, created_at, first_name, last_name, email, mobile_phone, requested_date, is_emergency, description, appointment_type, is_scheduled, scheduled_date, created_by, scheduled_by, is_cancelled, requested_time, scheduled_time, practice_id, modified_at)
VALUES (
    gen_random_uuid(), 
    NOW(),
    $1, 
    $2, 
    $3, 
    $4,
    $5, 
    $6, 
    $7, 
    $8, 
    $9, 
    $10, 
    $11, 
    $12, 
    $13, 
    $14, 
    $15, 
    $16, 
    NOW()
)
RETURNING id, created_at, first_name, last_name, email, mobile_phone, requested_date, is_emergency, description, appointment_type, requested_time, practice_id, modified_at
`

type CreateAppointmentParams struct {
	FirstName       string
	LastName        string
	Email           string
	MobilePhone     string
	RequestedDate   time.Time
	IsEmergency     bool
	Description     *string
	AppointmentType *string
	IsScheduled     bool
	ScheduledDate   *time.Time
	CreatedBy       *uuid.UUID
	ScheduledBy     *uuid.UUID
	IsCancelled     bool
	RequestedTime   string
	ScheduledTime   *string
	PracticeID      uuid.UUID
}

type CreateAppointmentRow struct {
	ID              uuid.UUID
	CreatedAt       time.Time
	FirstName       string
	LastName        string
	Email           string
	MobilePhone     string
	RequestedDate   time.Time
	IsEmergency     bool
	Description     *string
	AppointmentType *string
	RequestedTime   string
	PracticeID      uuid.UUID
	ModifiedAt      time.Time
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (CreateAppointmentRow, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.MobilePhone,
		arg.RequestedDate,
		arg.IsEmergency,
		arg.Description,
		arg.AppointmentType,
		arg.IsScheduled,
		arg.ScheduledDate,
		arg.CreatedBy,
		arg.ScheduledBy,
		arg.IsCancelled,
		arg.RequestedTime,
		arg.ScheduledTime,
		arg.PracticeID,
	)
	var i CreateAppointmentRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.MobilePhone,
		&i.RequestedDate,
		&i.IsEmergency,
		&i.Description,
		&i.AppointmentType,
		&i.RequestedTime,
		&i.PracticeID,
		&i.ModifiedAt,
	)
	return i, err
}

const deleteAppointment = `-- name: DeleteAppointment :one
DELETE FROM appointments
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteAppointment(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteAppointment, id)
	err := row.Scan(&id)
	return id, err
}

const getAppointmentById = `-- name: GetAppointmentById :one
SELECT id, first_name, last_name, email, mobile_phone, requested_date, requested_time, is_emergency, description, appointment_type, is_scheduled, scheduled_date, scheduled_time, practice_id, created_by, scheduled_by, is_cancelled, created_at, modified_at FROM appointments WHERE id = $1
`

func (q *Queries) GetAppointmentById(ctx context.Context, id uuid.UUID) (Appointment, error) {
	row := q.db.QueryRow(ctx, getAppointmentById, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.MobilePhone,
		&i.RequestedDate,
		&i.RequestedTime,
		&i.IsEmergency,
		&i.Description,
		&i.AppointmentType,
		&i.IsScheduled,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.PracticeID,
		&i.CreatedBy,
		&i.ScheduledBy,
		&i.IsCancelled,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getAppointments = `-- name: GetAppointments :many

SELECT id, first_name, last_name, email, mobile_phone, requested_date, requested_time, is_emergency, description, appointment_type, is_scheduled, scheduled_date, scheduled_time, practice_id, created_by, scheduled_by, is_cancelled, created_at, modified_at FROM appointments
`

func (q *Queries) GetAppointments(ctx context.Context) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, getAppointments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.MobilePhone,
			&i.RequestedDate,
			&i.RequestedTime,
			&i.IsEmergency,
			&i.Description,
			&i.AppointmentType,
			&i.IsScheduled,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.PracticeID,
			&i.CreatedBy,
			&i.ScheduledBy,
			&i.IsCancelled,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppointment = `-- name: UpdateAppointment :one
UPDATE appointments
SET scheduled_date = COALESCE($1, scheduled_date),
    scheduled_time = COALESCE($2, scheduled_time),
    is_scheduled = COALESCE($3, is_scheduled),
    is_cancelled = COALESCE($4, is_cancelled),
    modified_at = NOW()
WHERE id = $5
RETURNING id, first_name, last_name, email, mobile_phone, requested_date, requested_time, is_emergency, description, appointment_type, is_scheduled, scheduled_date, scheduled_time, practice_id, created_by, scheduled_by, is_cancelled, created_at, modified_at
`

type UpdateAppointmentParams struct {
	ScheduledDate *time.Time
	ScheduledTime *string
	IsScheduled   *bool
	IsCancelled   *bool
	ID            uuid.UUID
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointment,
		arg.ScheduledDate,
		arg.ScheduledTime,
		arg.IsScheduled,
		arg.IsCancelled,
		arg.ID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.MobilePhone,
		&i.RequestedDate,
		&i.RequestedTime,
		&i.IsEmergency,
		&i.Description,
		&i.AppointmentType,
		&i.IsScheduled,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.PracticeID,
		&i.CreatedBy,
		&i.ScheduledBy,
		&i.IsCancelled,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}
