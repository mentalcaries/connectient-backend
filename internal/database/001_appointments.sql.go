// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 001_appointments.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (id, created_at, first_name, last_name, email, mobile_phone, requested_date, is_emergency, description, appointment_type, is_scheduled, scheduled_date, created_by, scheduled_by, is_cancelled, requested_time, scheduled_time, practice_id, modified_at)
VALUES (
    gen_random_uuid(), 
    NOW(),
    $1, 
    $2, 
    $3, 
    $4,
    $5, 
    $6, 
    $7, 
    $8, 
    $9, 
    $10, 
    $11, 
    $12, 
    $13, 
    $14, 
    $15, 
    $16, 
    NOW()
)
RETURNING id, first_name, last_name, email, mobile_phone, requested_date, requested_time, is_emergency, description, appointment_type, is_scheduled, scheduled_date, scheduled_time, practice_id, created_by, scheduled_by, is_cancelled, created_at, modified_at
`

type CreateAppointmentParams struct {
	FirstName       string
	LastName        string
	Email           string
	MobilePhone     string
	RequestedDate   time.Time
	IsEmergency     bool
	Description     *string
	AppointmentType *string
	IsScheduled     bool
	ScheduledDate   *time.Time
	CreatedBy       *uuid.UUID
	ScheduledBy     *uuid.UUID
	IsCancelled     bool
	RequestedTime   string
	ScheduledTime   *string
	PracticeID      uuid.UUID
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.MobilePhone,
		arg.RequestedDate,
		arg.IsEmergency,
		arg.Description,
		arg.AppointmentType,
		arg.IsScheduled,
		arg.ScheduledDate,
		arg.CreatedBy,
		arg.ScheduledBy,
		arg.IsCancelled,
		arg.RequestedTime,
		arg.ScheduledTime,
		arg.PracticeID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.MobilePhone,
		&i.RequestedDate,
		&i.RequestedTime,
		&i.IsEmergency,
		&i.Description,
		&i.AppointmentType,
		&i.IsScheduled,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.PracticeID,
		&i.CreatedBy,
		&i.ScheduledBy,
		&i.IsCancelled,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getAppointments = `-- name: GetAppointments :many

SELECT id, first_name, last_name, email, mobile_phone, requested_date, requested_time, is_emergency, description, appointment_type, is_scheduled, scheduled_date, scheduled_time, practice_id, created_by, scheduled_by, is_cancelled, created_at, modified_at FROM appointments
`

func (q *Queries) GetAppointments(ctx context.Context) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, getAppointments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.MobilePhone,
			&i.RequestedDate,
			&i.RequestedTime,
			&i.IsEmergency,
			&i.Description,
			&i.AppointmentType,
			&i.IsScheduled,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.PracticeID,
			&i.CreatedBy,
			&i.ScheduledBy,
			&i.IsCancelled,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
